"""
единственная функция bracket_seqence_checker проверяет является ли строка "правильной"

_console_run для запуска из консоли
"""

import logging
import typing
import sys

logging.basicConfig(level=logging.INFO)

ENDING_BRACKETS = {
    ']',
    '}',
    ')',
}

OPPOSITE_BRACKETS = {
    ']': '[',
    '}': '{',
    ')': '(',
}


def bracket_seqence_checker(bracket_sequence: str) -> bool:
    """
    проверяет что переданная последовательность является правильной.
    правильная последовательность может быть построена следующим образом:
    1) [], (), {} - правильные последовательности
    2) если правильную последовательность вложить в другую правильную последовательность, то получится правильная посл.
    3) конкатенация правильных последовательностей - правильная последовательность

    например:
    1. [] - правильная по определению
    2. ([]) - правильная, т.к. внутри правильной последовательности () лежит правильная последовательность из п.1
    3. {}([]) - правильная, т.к. правильная последовательность {} соединена с последовательностью п.2

    отсюда алгоритм определения что последовательность является правильной:
    1. если мы нашли первую закрывающую скобку, то рядом с ней (соседняя слева) должна быть её открывающая скобка -
    такая последовательность будет правильной
    2. вычеркнем эту правильную последовательность из строки
    3. повторить с п.1 пока не останется пустая строка

    если какой-то пункт не выполнится, то последовательность неправильная
    :param bracket_sequence: исходная строка, состоящая только из [,],(,),{,}
    :return: True если строка правильная, False - неправильная
    """
    if not isinstance(bracket_sequence, str):
        raise Exception('bracket_sequence должна быть строкой!')

    # в задании сказано что в строке только [](){}
    # if {'(', ')', '[', ']', '{', '}'}.issuperset(set(bracket_sequence)):
    #     raise Exception('Передана неправильная строка!')

    # каждая открывающая скобка должна иметь закрывающую
    # отсюда необходимое условие корректности строки: чётное кол-во элементов
    if len(bracket_sequence) % 2 != 0:
        logging.info(f'{bracket_sequence} = False')
        return False

    # вместо вычёркивания будем хранить предыдущие открывающие скобки в стеке.
    # очевидно что вычёркивание из строки и удаление из стека открывающих скобок - это эквивалентные подходы
    # (разве что стек эффективнее)
    stack: typing.List[str] = []
    # бежим по строке в поисках открывающей скобки
    for i in bracket_sequence:
        if i in ENDING_BRACKETS:
            # если стек пустой, а мы нашли закрывающую скобку - то последовательность, очевидно, неправильная
            # либо символ должен быть противоположный закрывающему
            if (not stack) or (stack.pop() != OPPOSITE_BRACKETS[i]):
                logging.info(f'{bracket_sequence} = False')
                return False
        else:
            stack.append(i)

    # стек должен остаться пустым
    # например, при строке '[[' мы дойдём сюда, хотя последовательность неправильная
    result = not stack
    logging.info(f'{bracket_sequence} = {result}')
    return result


def _console_run():
    """
    для запуска программы из консоли.
    вызывает bracket_seqence_checker c аргументом из консоли
    :return: см. bracket_seqence_checker
    """
    if len(sys.argv) != 2:
        raise Exception('Нужно передать ровно 1 аргумент: строку, состоящую только из символом (,),[,],{,}')

    bracket_seqence_checker(sys.argv[1])
